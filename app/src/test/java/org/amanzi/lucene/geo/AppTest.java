/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package org.amanzi.lucene.geo;

import org.hamcrest.BaseMatcher;
import org.hamcrest.Description;
import org.hamcrest.Matcher;
import org.junit.Test;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.PrintStream;
import java.nio.file.Path;
import java.util.Objects;

import static org.hamcrest.CoreMatchers.containsString;
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.MatcherAssert.assertThat;

public class AppTest {
    @Test
    public void shouldFailOnMissingName() {
        ByteArrayOutputStream output = new ByteArrayOutputStream();
        System.setOut(new PrintStream(output));
        App.main(new String[]{});
        assertExpectedHelpOutput(output.toString(), false, false, App.DEFAULT_DIR, App.DEFAULT_WIDTH, App.DEFAULT_HEIGHT, App.DEFAULT_MARGIN);
    }

    @Test
    public void shouldNotUnderstandUnknownOptions() {
        for (String unknown : new String[]{"-V", "-w", "-m", "-d"}) {
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            System.setOut(new PrintStream(out));
            ByteArrayOutputStream err = new ByteArrayOutputStream();
            System.setErr(new PrintStream(err));
            App.main(new String[]{unknown});
            assertThat("Expected error message", err.toString(), containsString("Unknown option: " + unknown));
            assertThat("Expected help output", out.toString(), containsString("usage: lucene"));
        }
    }

    @Test
    public void shouldUnderstandOptions() {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        System.setOut(new PrintStream(out));
        App.main(new String[]{"-v", "-l", "-D", "/tmp/another", "-W", "5000", "-H", "3000", "-M", "1234"});
        assertThat("Expected help output", out.toString(), containsString("usage: lucene"));
        assertExpectedHelpOutput(out.toString(), true, true, "/tmp/another", 5000, 3000, 1234);
    }

    @Test
    public void shouldFailOnMissingClasspathFile() {
        ByteArrayOutputStream err = new ByteArrayOutputStream();
        System.setErr(new PrintStream(err));
        App.main(new String[]{"invalid"});
        assertThat("Expected error message", err.toString(), containsString("resource not found: invalid.geojson.gz"));
    }

    @Test
    public void shouldFailOnMissingPathFile() {
        ByteArrayOutputStream err = new ByteArrayOutputStream();
        System.setErr(new PrintStream(err));
        App.main(new String[]{"src/main/resources/org/apache/lucene/geo/invalid.geojson.gz"});
        assertThat("Expected error message", err.toString(), containsString("invalid.geojson.gz (No such file or directory)"));
        assertThat("Expected many image files", countFilesIn(App.DEFAULT_DIR, "lucene-10563-1"), greaterThan(100));
    }

    @Test
    public void shouldSucceedWithExistingClasspathFile() {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        System.setOut(new PrintStream(out));
        ByteArrayOutputStream err = new ByteArrayOutputStream();
        System.setErr(new PrintStream(err));
        App.main(new String[]{"lucene-10563-1"});
        assertThat("Did not expect an error message", err.toString(), is(emptyString()));
        assertThat("Expected polygon WKT", out.toString(), containsString("POLYGON("));
        assertThat("Expected many image files", countFilesIn(App.DEFAULT_DIR, "lucene-10563-1"), greaterThan(400));
    }

    @Test
    public void shouldSucceedWithExistingPathFile() {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        System.setOut(new PrintStream(out));
        ByteArrayOutputStream err = new ByteArrayOutputStream();
        System.setErr(new PrintStream(err));
        App.main(new String[]{"src/main/resources/org/apache/lucene/geo/lucene-10563-1.geojson.gz"});
        assertThat("Did not expect an error message", err.toString(), is(emptyString()));
        assertThat("Expected polygon WKT", out.toString(), containsString("POLYGON("));
        assertThat("Expected many image files", countFilesIn(App.DEFAULT_DIR, "lucene-10563-1"), greaterThan(400));
    }

    private void assertExpectedHelpOutput(String text, boolean verbose, boolean labels, String dir, int width, int height, int margin) {
        assertThat("Expected help output", text, containsString("usage: lucene"));
        assertThat("Expected verbose " + verbose, text, containsString("Verbose output: " + verbose));
        assertThat("Expected labels " + verbose, text, containsString("Add labels to images: " + labels));
        assertThat("Expected dir " + dir, text, containsString("Set the output directory for image files: '" + dir));
        assertThat("Expected width " + width, text, containsString("Set the image width: " + width));
        assertThat("Expected height " + height, text, containsString("Set the image height: " + height));
        assertThat("Expected margin " + margin, text, containsString("Set the image margin: " + margin));
    }

    private static int countFilesIn(String path, String name) {
        File dir = Path.of(path).resolve(name).toFile();
        return Objects.requireNonNull(dir.listFiles((d, n) -> n.startsWith(name))).length;
    }

    private static Matcher<String> emptyString() {
        return new EmptyString();
    }

    private static class EmptyString extends BaseMatcher<String> {

        @Override
        public boolean matches(Object item) {
            if (item instanceof String) {
                return ((String) item).length() == 0;
            }
            return false;
        }

        @Override
        public void describeTo(Description description) {
            description.appendText("empty string");
        }
    }

    private static Matcher<Integer> greaterThan(int minValue) {
        return new GreaterThan(minValue);
    }

    private static class GreaterThan extends BaseMatcher<Integer> {
        private final int minValue;

        private GreaterThan(int minValue) {

            this.minValue = minValue;
        }

        @Override
        public boolean matches(Object item) {
            if (item instanceof Number) {
                return ((Number) item).intValue() > minValue;
            }
            return false;
        }

        @Override
        public void describeTo(Description description) {
            description.appendText("number greater than " + minValue);
        }
    }
}
